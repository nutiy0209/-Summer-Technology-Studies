/* eslint-disable */
// tslint:disable
/**
 * FastAPI
 *
 *
 * OpenAPI spec version: 0.1.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator+.
 * https://github.com/karlvr/openapi-generator-plus
 * Do not edit the class manually.
 */
import { BASE_PATH, BaseAPI, RequiredError, defaultFetch } from "./runtime";
/**
 * ApiApi - fetch parameter creator
 * @export
 */
export const ApiApiFetchParamCreator = function (configuration) {
    return {
        /**
         * @summary Add
         * @param {string} collectionId
         * @param {Api.AddEmbedding} request
         * @param {RequestInit} [options] Override http request option.
         * @throws {RequiredError}
         */
        add(collectionId, request, options = {}) {
            // verify required parameter 'collectionId' is not null or undefined
            if (collectionId === null || collectionId === undefined) {
                throw new RequiredError('collectionId', 'Required parameter collectionId was null or undefined when calling add.');
            }
            // verify required parameter 'request' is not null or undefined
            if (request === null || request === undefined) {
                throw new RequiredError('request', 'Required parameter request was null or undefined when calling add.');
            }
            let localVarPath = `/api/v1/collections/{collection_id}/add`
                .replace('{collection_id}', encodeURIComponent(String(collectionId)));
            const localVarPathQueryStart = localVarPath.indexOf("?");
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = options.headers ? new Headers(options.headers) : new Headers();
            const localVarQueryParameter = new URLSearchParams(localVarPathQueryStart !== -1 ? localVarPath.substring(localVarPathQueryStart + 1) : "");
            if (localVarPathQueryStart !== -1) {
                localVarPath = localVarPath.substring(0, localVarPathQueryStart);
            }
            localVarHeaderParameter.set('Content-Type', 'application/json');
            localVarRequestOptions.headers = localVarHeaderParameter;
            if (request !== undefined) {
                localVarRequestOptions.body = JSON.stringify(request || {});
            }
            const localVarQueryParameterString = localVarQueryParameter.toString();
            if (localVarQueryParameterString) {
                localVarPath += "?" + localVarQueryParameterString;
            }
            return {
                url: localVarPath,
                options: localVarRequestOptions,
            };
        },
        /**
         * @summary Delete
         * @param {string} collectionId
         * @param {Api.DeleteEmbedding} request
         * @param {RequestInit} [options] Override http request option.
         * @throws {RequiredError}
         */
        aDelete(collectionId, request, options = {}) {
            // verify required parameter 'collectionId' is not null or undefined
            if (collectionId === null || collectionId === undefined) {
                throw new RequiredError('collectionId', 'Required parameter collectionId was null or undefined when calling aDelete.');
            }
            // verify required parameter 'request' is not null or undefined
            if (request === null || request === undefined) {
                throw new RequiredError('request', 'Required parameter request was null or undefined when calling aDelete.');
            }
            let localVarPath = `/api/v1/collections/{collection_id}/delete`
                .replace('{collection_id}', encodeURIComponent(String(collectionId)));
            const localVarPathQueryStart = localVarPath.indexOf("?");
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = options.headers ? new Headers(options.headers) : new Headers();
            const localVarQueryParameter = new URLSearchParams(localVarPathQueryStart !== -1 ? localVarPath.substring(localVarPathQueryStart + 1) : "");
            if (localVarPathQueryStart !== -1) {
                localVarPath = localVarPath.substring(0, localVarPathQueryStart);
            }
            localVarHeaderParameter.set('Content-Type', 'application/json');
            localVarRequestOptions.headers = localVarHeaderParameter;
            if (request !== undefined) {
                localVarRequestOptions.body = JSON.stringify(request || {});
            }
            const localVarQueryParameterString = localVarQueryParameter.toString();
            if (localVarQueryParameterString) {
                localVarPath += "?" + localVarQueryParameterString;
            }
            return {
                url: localVarPath,
                options: localVarRequestOptions,
            };
        },
        /**
         * @summary Get
         * @param {string} collectionId
         * @param {Api.GetEmbedding} request
         * @param {RequestInit} [options] Override http request option.
         * @throws {RequiredError}
         */
        aGet(collectionId, request, options = {}) {
            // verify required parameter 'collectionId' is not null or undefined
            if (collectionId === null || collectionId === undefined) {
                throw new RequiredError('collectionId', 'Required parameter collectionId was null or undefined when calling aGet.');
            }
            // verify required parameter 'request' is not null or undefined
            if (request === null || request === undefined) {
                throw new RequiredError('request', 'Required parameter request was null or undefined when calling aGet.');
            }
            let localVarPath = `/api/v1/collections/{collection_id}/get`
                .replace('{collection_id}', encodeURIComponent(String(collectionId)));
            const localVarPathQueryStart = localVarPath.indexOf("?");
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = options.headers ? new Headers(options.headers) : new Headers();
            const localVarQueryParameter = new URLSearchParams(localVarPathQueryStart !== -1 ? localVarPath.substring(localVarPathQueryStart + 1) : "");
            if (localVarPathQueryStart !== -1) {
                localVarPath = localVarPath.substring(0, localVarPathQueryStart);
            }
            localVarHeaderParameter.set('Content-Type', 'application/json');
            localVarRequestOptions.headers = localVarHeaderParameter;
            if (request !== undefined) {
                localVarRequestOptions.body = JSON.stringify(request || {});
            }
            const localVarQueryParameterString = localVarQueryParameter.toString();
            if (localVarQueryParameterString) {
                localVarPath += "?" + localVarQueryParameterString;
            }
            return {
                url: localVarPath,
                options: localVarRequestOptions,
            };
        },
        /**
         * @summary Count
         * @param {string} collectionId
         * @param {RequestInit} [options] Override http request option.
         * @throws {RequiredError}
         */
        count(collectionId, options = {}) {
            // verify required parameter 'collectionId' is not null or undefined
            if (collectionId === null || collectionId === undefined) {
                throw new RequiredError('collectionId', 'Required parameter collectionId was null or undefined when calling count.');
            }
            let localVarPath = `/api/v1/collections/{collection_id}/count`
                .replace('{collection_id}', encodeURIComponent(String(collectionId)));
            const localVarPathQueryStart = localVarPath.indexOf("?");
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = options.headers ? new Headers(options.headers) : new Headers();
            const localVarQueryParameter = new URLSearchParams(localVarPathQueryStart !== -1 ? localVarPath.substring(localVarPathQueryStart + 1) : "");
            if (localVarPathQueryStart !== -1) {
                localVarPath = localVarPath.substring(0, localVarPathQueryStart);
            }
            localVarRequestOptions.headers = localVarHeaderParameter;
            const localVarQueryParameterString = localVarQueryParameter.toString();
            if (localVarQueryParameterString) {
                localVarPath += "?" + localVarQueryParameterString;
            }
            return {
                url: localVarPath,
                options: localVarRequestOptions,
            };
        },
        /**
         * @summary Create Collection
         * @param {Api.CreateCollection} request
         * @param {RequestInit} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCollection(request, options = {}) {
            // verify required parameter 'request' is not null or undefined
            if (request === null || request === undefined) {
                throw new RequiredError('request', 'Required parameter request was null or undefined when calling createCollection.');
            }
            let localVarPath = `/api/v1/collections`;
            const localVarPathQueryStart = localVarPath.indexOf("?");
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = options.headers ? new Headers(options.headers) : new Headers();
            const localVarQueryParameter = new URLSearchParams(localVarPathQueryStart !== -1 ? localVarPath.substring(localVarPathQueryStart + 1) : "");
            if (localVarPathQueryStart !== -1) {
                localVarPath = localVarPath.substring(0, localVarPathQueryStart);
            }
            localVarHeaderParameter.set('Content-Type', 'application/json');
            localVarRequestOptions.headers = localVarHeaderParameter;
            if (request !== undefined) {
                localVarRequestOptions.body = JSON.stringify(request || {});
            }
            const localVarQueryParameterString = localVarQueryParameter.toString();
            if (localVarQueryParameterString) {
                localVarPath += "?" + localVarQueryParameterString;
            }
            return {
                url: localVarPath,
                options: localVarRequestOptions,
            };
        },
        /**
         * @summary Create Index
         * @param {string} collectionName
         * @param {RequestInit} [options] Override http request option.
         * @throws {RequiredError}
         */
        createIndex(collectionName, options = {}) {
            // verify required parameter 'collectionName' is not null or undefined
            if (collectionName === null || collectionName === undefined) {
                throw new RequiredError('collectionName', 'Required parameter collectionName was null or undefined when calling createIndex.');
            }
            let localVarPath = `/api/v1/collections/{collection_name}/create_index`
                .replace('{collection_name}', encodeURIComponent(String(collectionName)));
            const localVarPathQueryStart = localVarPath.indexOf("?");
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = options.headers ? new Headers(options.headers) : new Headers();
            const localVarQueryParameter = new URLSearchParams(localVarPathQueryStart !== -1 ? localVarPath.substring(localVarPathQueryStart + 1) : "");
            if (localVarPathQueryStart !== -1) {
                localVarPath = localVarPath.substring(0, localVarPathQueryStart);
            }
            localVarRequestOptions.headers = localVarHeaderParameter;
            const localVarQueryParameterString = localVarQueryParameter.toString();
            if (localVarQueryParameterString) {
                localVarPath += "?" + localVarQueryParameterString;
            }
            return {
                url: localVarPath,
                options: localVarRequestOptions,
            };
        },
        /**
         * @summary Delete Collection
         * @param {string} collectionName
         * @param {RequestInit} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCollection(collectionName, options = {}) {
            // verify required parameter 'collectionName' is not null or undefined
            if (collectionName === null || collectionName === undefined) {
                throw new RequiredError('collectionName', 'Required parameter collectionName was null or undefined when calling deleteCollection.');
            }
            let localVarPath = `/api/v1/collections/{collection_name}`
                .replace('{collection_name}', encodeURIComponent(String(collectionName)));
            const localVarPathQueryStart = localVarPath.indexOf("?");
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = options.headers ? new Headers(options.headers) : new Headers();
            const localVarQueryParameter = new URLSearchParams(localVarPathQueryStart !== -1 ? localVarPath.substring(localVarPathQueryStart + 1) : "");
            if (localVarPathQueryStart !== -1) {
                localVarPath = localVarPath.substring(0, localVarPathQueryStart);
            }
            localVarRequestOptions.headers = localVarHeaderParameter;
            const localVarQueryParameterString = localVarQueryParameter.toString();
            if (localVarQueryParameterString) {
                localVarPath += "?" + localVarQueryParameterString;
            }
            return {
                url: localVarPath,
                options: localVarRequestOptions,
            };
        },
        /**
         * @summary Get Collection
         * @param {string} collectionName
         * @param {RequestInit} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCollection(collectionName, options = {}) {
            // verify required parameter 'collectionName' is not null or undefined
            if (collectionName === null || collectionName === undefined) {
                throw new RequiredError('collectionName', 'Required parameter collectionName was null or undefined when calling getCollection.');
            }
            let localVarPath = `/api/v1/collections/{collection_name}`
                .replace('{collection_name}', encodeURIComponent(String(collectionName)));
            const localVarPathQueryStart = localVarPath.indexOf("?");
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = options.headers ? new Headers(options.headers) : new Headers();
            const localVarQueryParameter = new URLSearchParams(localVarPathQueryStart !== -1 ? localVarPath.substring(localVarPathQueryStart + 1) : "");
            if (localVarPathQueryStart !== -1) {
                localVarPath = localVarPath.substring(0, localVarPathQueryStart);
            }
            localVarRequestOptions.headers = localVarHeaderParameter;
            const localVarQueryParameterString = localVarQueryParameter.toString();
            if (localVarQueryParameterString) {
                localVarPath += "?" + localVarQueryParameterString;
            }
            return {
                url: localVarPath,
                options: localVarRequestOptions,
            };
        },
        /**
         * @summary Get Nearest Neighbors
         * @param {string} collectionId
         * @param {Api.QueryEmbedding} request
         * @param {RequestInit} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNearestNeighbors(collectionId, request, options = {}) {
            // verify required parameter 'collectionId' is not null or undefined
            if (collectionId === null || collectionId === undefined) {
                throw new RequiredError('collectionId', 'Required parameter collectionId was null or undefined when calling getNearestNeighbors.');
            }
            // verify required parameter 'request' is not null or undefined
            if (request === null || request === undefined) {
                throw new RequiredError('request', 'Required parameter request was null or undefined when calling getNearestNeighbors.');
            }
            let localVarPath = `/api/v1/collections/{collection_id}/query`
                .replace('{collection_id}', encodeURIComponent(String(collectionId)));
            const localVarPathQueryStart = localVarPath.indexOf("?");
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = options.headers ? new Headers(options.headers) : new Headers();
            const localVarQueryParameter = new URLSearchParams(localVarPathQueryStart !== -1 ? localVarPath.substring(localVarPathQueryStart + 1) : "");
            if (localVarPathQueryStart !== -1) {
                localVarPath = localVarPath.substring(0, localVarPathQueryStart);
            }
            localVarHeaderParameter.set('Content-Type', 'application/json');
            localVarRequestOptions.headers = localVarHeaderParameter;
            if (request !== undefined) {
                localVarRequestOptions.body = JSON.stringify(request || {});
            }
            const localVarQueryParameterString = localVarQueryParameter.toString();
            if (localVarQueryParameterString) {
                localVarPath += "?" + localVarQueryParameterString;
            }
            return {
                url: localVarPath,
                options: localVarRequestOptions,
            };
        },
        /**
         * @summary Heartbeat
         * @param {RequestInit} [options] Override http request option.
         * @throws {RequiredError}
         */
        heartbeat(options = {}) {
            let localVarPath = `/api/v1/heartbeat`;
            const localVarPathQueryStart = localVarPath.indexOf("?");
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = options.headers ? new Headers(options.headers) : new Headers();
            const localVarQueryParameter = new URLSearchParams(localVarPathQueryStart !== -1 ? localVarPath.substring(localVarPathQueryStart + 1) : "");
            if (localVarPathQueryStart !== -1) {
                localVarPath = localVarPath.substring(0, localVarPathQueryStart);
            }
            localVarRequestOptions.headers = localVarHeaderParameter;
            const localVarQueryParameterString = localVarQueryParameter.toString();
            if (localVarQueryParameterString) {
                localVarPath += "?" + localVarQueryParameterString;
            }
            return {
                url: localVarPath,
                options: localVarRequestOptions,
            };
        },
        /**
         * @summary List Collections
         * @param {RequestInit} [options] Override http request option.
         * @throws {RequiredError}
         */
        listCollections(options = {}) {
            let localVarPath = `/api/v1/collections`;
            const localVarPathQueryStart = localVarPath.indexOf("?");
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = options.headers ? new Headers(options.headers) : new Headers();
            const localVarQueryParameter = new URLSearchParams(localVarPathQueryStart !== -1 ? localVarPath.substring(localVarPathQueryStart + 1) : "");
            if (localVarPathQueryStart !== -1) {
                localVarPath = localVarPath.substring(0, localVarPathQueryStart);
            }
            localVarRequestOptions.headers = localVarHeaderParameter;
            const localVarQueryParameterString = localVarQueryParameter.toString();
            if (localVarQueryParameterString) {
                localVarPath += "?" + localVarQueryParameterString;
            }
            return {
                url: localVarPath,
                options: localVarRequestOptions,
            };
        },
        /**
         * @summary Raw Sql
         * @param {Api.RawSql} request
         * @param {RequestInit} [options] Override http request option.
         * @throws {RequiredError}
         */
        rawSql(request, options = {}) {
            // verify required parameter 'request' is not null or undefined
            if (request === null || request === undefined) {
                throw new RequiredError('request', 'Required parameter request was null or undefined when calling rawSql.');
            }
            let localVarPath = `/api/v1/raw_sql`;
            const localVarPathQueryStart = localVarPath.indexOf("?");
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = options.headers ? new Headers(options.headers) : new Headers();
            const localVarQueryParameter = new URLSearchParams(localVarPathQueryStart !== -1 ? localVarPath.substring(localVarPathQueryStart + 1) : "");
            if (localVarPathQueryStart !== -1) {
                localVarPath = localVarPath.substring(0, localVarPathQueryStart);
            }
            localVarHeaderParameter.set('Content-Type', 'application/json');
            localVarRequestOptions.headers = localVarHeaderParameter;
            if (request !== undefined) {
                localVarRequestOptions.body = JSON.stringify(request || {});
            }
            const localVarQueryParameterString = localVarQueryParameter.toString();
            if (localVarQueryParameterString) {
                localVarPath += "?" + localVarQueryParameterString;
            }
            return {
                url: localVarPath,
                options: localVarRequestOptions,
            };
        },
        /**
         * @summary Reset
         * @param {RequestInit} [options] Override http request option.
         * @throws {RequiredError}
         */
        reset(options = {}) {
            let localVarPath = `/api/v1/reset`;
            const localVarPathQueryStart = localVarPath.indexOf("?");
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = options.headers ? new Headers(options.headers) : new Headers();
            const localVarQueryParameter = new URLSearchParams(localVarPathQueryStart !== -1 ? localVarPath.substring(localVarPathQueryStart + 1) : "");
            if (localVarPathQueryStart !== -1) {
                localVarPath = localVarPath.substring(0, localVarPathQueryStart);
            }
            localVarRequestOptions.headers = localVarHeaderParameter;
            const localVarQueryParameterString = localVarQueryParameter.toString();
            if (localVarQueryParameterString) {
                localVarPath += "?" + localVarQueryParameterString;
            }
            return {
                url: localVarPath,
                options: localVarRequestOptions,
            };
        },
        /**
         * @summary Root
         * @param {RequestInit} [options] Override http request option.
         * @throws {RequiredError}
         */
        root(options = {}) {
            let localVarPath = `/api/v1`;
            const localVarPathQueryStart = localVarPath.indexOf("?");
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = options.headers ? new Headers(options.headers) : new Headers();
            const localVarQueryParameter = new URLSearchParams(localVarPathQueryStart !== -1 ? localVarPath.substring(localVarPathQueryStart + 1) : "");
            if (localVarPathQueryStart !== -1) {
                localVarPath = localVarPath.substring(0, localVarPathQueryStart);
            }
            localVarRequestOptions.headers = localVarHeaderParameter;
            const localVarQueryParameterString = localVarQueryParameter.toString();
            if (localVarQueryParameterString) {
                localVarPath += "?" + localVarQueryParameterString;
            }
            return {
                url: localVarPath,
                options: localVarRequestOptions,
            };
        },
        /**
         * @summary Update
         * @param {string} collectionId
         * @param {Api.UpdateEmbedding} request
         * @param {RequestInit} [options] Override http request option.
         * @throws {RequiredError}
         */
        update(collectionId, request, options = {}) {
            // verify required parameter 'collectionId' is not null or undefined
            if (collectionId === null || collectionId === undefined) {
                throw new RequiredError('collectionId', 'Required parameter collectionId was null or undefined when calling update.');
            }
            // verify required parameter 'request' is not null or undefined
            if (request === null || request === undefined) {
                throw new RequiredError('request', 'Required parameter request was null or undefined when calling update.');
            }
            let localVarPath = `/api/v1/collections/{collection_id}/update`
                .replace('{collection_id}', encodeURIComponent(String(collectionId)));
            const localVarPathQueryStart = localVarPath.indexOf("?");
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = options.headers ? new Headers(options.headers) : new Headers();
            const localVarQueryParameter = new URLSearchParams(localVarPathQueryStart !== -1 ? localVarPath.substring(localVarPathQueryStart + 1) : "");
            if (localVarPathQueryStart !== -1) {
                localVarPath = localVarPath.substring(0, localVarPathQueryStart);
            }
            localVarHeaderParameter.set('Content-Type', 'application/json');
            localVarRequestOptions.headers = localVarHeaderParameter;
            if (request !== undefined) {
                localVarRequestOptions.body = JSON.stringify(request || {});
            }
            const localVarQueryParameterString = localVarQueryParameter.toString();
            if (localVarQueryParameterString) {
                localVarPath += "?" + localVarQueryParameterString;
            }
            return {
                url: localVarPath,
                options: localVarRequestOptions,
            };
        },
        /**
         * @summary Update Collection
         * @param {string} collectionId
         * @param {Api.UpdateCollection} request
         * @param {RequestInit} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCollection(collectionId, request, options = {}) {
            // verify required parameter 'collectionId' is not null or undefined
            if (collectionId === null || collectionId === undefined) {
                throw new RequiredError('collectionId', 'Required parameter collectionId was null or undefined when calling updateCollection.');
            }
            // verify required parameter 'request' is not null or undefined
            if (request === null || request === undefined) {
                throw new RequiredError('request', 'Required parameter request was null or undefined when calling updateCollection.');
            }
            let localVarPath = `/api/v1/collections/{collection_id}`
                .replace('{collection_id}', encodeURIComponent(String(collectionId)));
            const localVarPathQueryStart = localVarPath.indexOf("?");
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = options.headers ? new Headers(options.headers) : new Headers();
            const localVarQueryParameter = new URLSearchParams(localVarPathQueryStart !== -1 ? localVarPath.substring(localVarPathQueryStart + 1) : "");
            if (localVarPathQueryStart !== -1) {
                localVarPath = localVarPath.substring(0, localVarPathQueryStart);
            }
            localVarHeaderParameter.set('Content-Type', 'application/json');
            localVarRequestOptions.headers = localVarHeaderParameter;
            if (request !== undefined) {
                localVarRequestOptions.body = JSON.stringify(request || {});
            }
            const localVarQueryParameterString = localVarQueryParameter.toString();
            if (localVarQueryParameterString) {
                localVarPath += "?" + localVarQueryParameterString;
            }
            return {
                url: localVarPath,
                options: localVarRequestOptions,
            };
        },
        /**
         * @summary Upsert
         * @param {string} collectionId
         * @param {Api.AddEmbedding} request
         * @param {RequestInit} [options] Override http request option.
         * @throws {RequiredError}
         */
        upsert(collectionId, request, options = {}) {
            // verify required parameter 'collectionId' is not null or undefined
            if (collectionId === null || collectionId === undefined) {
                throw new RequiredError('collectionId', 'Required parameter collectionId was null or undefined when calling upsert.');
            }
            // verify required parameter 'request' is not null or undefined
            if (request === null || request === undefined) {
                throw new RequiredError('request', 'Required parameter request was null or undefined when calling upsert.');
            }
            let localVarPath = `/api/v1/collections/{collection_id}/upsert`
                .replace('{collection_id}', encodeURIComponent(String(collectionId)));
            const localVarPathQueryStart = localVarPath.indexOf("?");
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = options.headers ? new Headers(options.headers) : new Headers();
            const localVarQueryParameter = new URLSearchParams(localVarPathQueryStart !== -1 ? localVarPath.substring(localVarPathQueryStart + 1) : "");
            if (localVarPathQueryStart !== -1) {
                localVarPath = localVarPath.substring(0, localVarPathQueryStart);
            }
            localVarHeaderParameter.set('Content-Type', 'application/json');
            localVarRequestOptions.headers = localVarHeaderParameter;
            if (request !== undefined) {
                localVarRequestOptions.body = JSON.stringify(request || {});
            }
            const localVarQueryParameterString = localVarQueryParameter.toString();
            if (localVarQueryParameterString) {
                localVarPath += "?" + localVarQueryParameterString;
            }
            return {
                url: localVarPath,
                options: localVarRequestOptions,
            };
        },
        /**
         * @summary Version
         * @param {RequestInit} [options] Override http request option.
         * @throws {RequiredError}
         */
        version(options = {}) {
            let localVarPath = `/api/v1/version`;
            const localVarPathQueryStart = localVarPath.indexOf("?");
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = options.headers ? new Headers(options.headers) : new Headers();
            const localVarQueryParameter = new URLSearchParams(localVarPathQueryStart !== -1 ? localVarPath.substring(localVarPathQueryStart + 1) : "");
            if (localVarPathQueryStart !== -1) {
                localVarPath = localVarPath.substring(0, localVarPathQueryStart);
            }
            localVarRequestOptions.headers = localVarHeaderParameter;
            const localVarQueryParameterString = localVarQueryParameter.toString();
            if (localVarQueryParameterString) {
                localVarPath += "?" + localVarQueryParameterString;
            }
            return {
                url: localVarPath,
                options: localVarRequestOptions,
            };
        },
    };
};
/**
 * ApiApi - functional programming interface
 * @export
 */
export const ApiApiFp = function (configuration) {
    return {
        /**
         * @summary Add
         * @param {string} collectionId
         * @param {Api.AddEmbedding} request
         * @param {RequestInit} [options] Override http request option.
         * @throws {RequiredError}
         */
        add(collectionId, request, options) {
            const localVarFetchArgs = ApiApiFetchParamCreator(configuration).add(collectionId, request, options);
            return (fetch = defaultFetch, basePath = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    const contentType = response.headers.get('Content-Type');
                    const mimeType = contentType ? contentType.replace(/;.*/, '') : undefined;
                    if (response.status === 201) {
                        if (mimeType === 'application/json') {
                            return response.json();
                        }
                        throw response;
                    }
                    if (response.status === 422) {
                        if (mimeType === 'application/json') {
                            throw response;
                        }
                        throw response;
                    }
                    throw response;
                });
            };
        },
        /**
         * @summary Delete
         * @param {string} collectionId
         * @param {Api.DeleteEmbedding} request
         * @param {RequestInit} [options] Override http request option.
         * @throws {RequiredError}
         */
        aDelete(collectionId, request, options) {
            const localVarFetchArgs = ApiApiFetchParamCreator(configuration).aDelete(collectionId, request, options);
            return (fetch = defaultFetch, basePath = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    const contentType = response.headers.get('Content-Type');
                    const mimeType = contentType ? contentType.replace(/;.*/, '') : undefined;
                    if (response.status === 200) {
                        if (mimeType === 'application/json') {
                            return response.json();
                        }
                        throw response;
                    }
                    if (response.status === 422) {
                        if (mimeType === 'application/json') {
                            throw response;
                        }
                        throw response;
                    }
                    throw response;
                });
            };
        },
        /**
         * @summary Get
         * @param {string} collectionId
         * @param {Api.GetEmbedding} request
         * @param {RequestInit} [options] Override http request option.
         * @throws {RequiredError}
         */
        aGet(collectionId, request, options) {
            const localVarFetchArgs = ApiApiFetchParamCreator(configuration).aGet(collectionId, request, options);
            return (fetch = defaultFetch, basePath = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    const contentType = response.headers.get('Content-Type');
                    const mimeType = contentType ? contentType.replace(/;.*/, '') : undefined;
                    if (response.status === 200) {
                        if (mimeType === 'application/json') {
                            return response.json();
                        }
                        throw response;
                    }
                    if (response.status === 422) {
                        if (mimeType === 'application/json') {
                            throw response;
                        }
                        throw response;
                    }
                    throw response;
                });
            };
        },
        /**
         * @summary Count
         * @param {string} collectionId
         * @param {RequestInit} [options] Override http request option.
         * @throws {RequiredError}
         */
        count(collectionId, options) {
            const localVarFetchArgs = ApiApiFetchParamCreator(configuration).count(collectionId, options);
            return (fetch = defaultFetch, basePath = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    const contentType = response.headers.get('Content-Type');
                    const mimeType = contentType ? contentType.replace(/;.*/, '') : undefined;
                    if (response.status === 200) {
                        if (mimeType === 'application/json') {
                            return response.json();
                        }
                        throw response;
                    }
                    if (response.status === 422) {
                        if (mimeType === 'application/json') {
                            throw response;
                        }
                        throw response;
                    }
                    throw response;
                });
            };
        },
        /**
         * @summary Create Collection
         * @param {Api.CreateCollection} request
         * @param {RequestInit} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCollection(request, options) {
            const localVarFetchArgs = ApiApiFetchParamCreator(configuration).createCollection(request, options);
            return (fetch = defaultFetch, basePath = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    const contentType = response.headers.get('Content-Type');
                    const mimeType = contentType ? contentType.replace(/;.*/, '') : undefined;
                    if (response.status === 200) {
                        if (mimeType === 'application/json') {
                            return response.json();
                        }
                        throw response;
                    }
                    if (response.status === 422) {
                        if (mimeType === 'application/json') {
                            throw response;
                        }
                        throw response;
                    }
                    throw response;
                });
            };
        },
        /**
         * @summary Create Index
         * @param {string} collectionName
         * @param {RequestInit} [options] Override http request option.
         * @throws {RequiredError}
         */
        createIndex(collectionName, options) {
            const localVarFetchArgs = ApiApiFetchParamCreator(configuration).createIndex(collectionName, options);
            return (fetch = defaultFetch, basePath = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    const contentType = response.headers.get('Content-Type');
                    const mimeType = contentType ? contentType.replace(/;.*/, '') : undefined;
                    if (response.status === 200) {
                        if (mimeType === 'application/json') {
                            return response.json();
                        }
                        throw response;
                    }
                    if (response.status === 422) {
                        if (mimeType === 'application/json') {
                            throw response;
                        }
                        throw response;
                    }
                    throw response;
                });
            };
        },
        /**
         * @summary Delete Collection
         * @param {string} collectionName
         * @param {RequestInit} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCollection(collectionName, options) {
            const localVarFetchArgs = ApiApiFetchParamCreator(configuration).deleteCollection(collectionName, options);
            return (fetch = defaultFetch, basePath = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    const contentType = response.headers.get('Content-Type');
                    const mimeType = contentType ? contentType.replace(/;.*/, '') : undefined;
                    if (response.status === 200) {
                        if (mimeType === 'application/json') {
                            return response.json();
                        }
                        throw response;
                    }
                    if (response.status === 422) {
                        if (mimeType === 'application/json') {
                            throw response;
                        }
                        throw response;
                    }
                    throw response;
                });
            };
        },
        /**
         * @summary Get Collection
         * @param {string} collectionName
         * @param {RequestInit} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCollection(collectionName, options) {
            const localVarFetchArgs = ApiApiFetchParamCreator(configuration).getCollection(collectionName, options);
            return (fetch = defaultFetch, basePath = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    const contentType = response.headers.get('Content-Type');
                    const mimeType = contentType ? contentType.replace(/;.*/, '') : undefined;
                    if (response.status === 200) {
                        if (mimeType === 'application/json') {
                            return response.json();
                        }
                        throw response;
                    }
                    if (response.status === 422) {
                        if (mimeType === 'application/json') {
                            throw response;
                        }
                        throw response;
                    }
                    throw response;
                });
            };
        },
        /**
         * @summary Get Nearest Neighbors
         * @param {string} collectionId
         * @param {Api.QueryEmbedding} request
         * @param {RequestInit} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNearestNeighbors(collectionId, request, options) {
            const localVarFetchArgs = ApiApiFetchParamCreator(configuration).getNearestNeighbors(collectionId, request, options);
            return (fetch = defaultFetch, basePath = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    const contentType = response.headers.get('Content-Type');
                    const mimeType = contentType ? contentType.replace(/;.*/, '') : undefined;
                    if (response.status === 200) {
                        if (mimeType === 'application/json') {
                            return response.json();
                        }
                        throw response;
                    }
                    if (response.status === 422) {
                        if (mimeType === 'application/json') {
                            throw response;
                        }
                        throw response;
                    }
                    throw response;
                });
            };
        },
        /**
         * @summary Heartbeat
         * @param {RequestInit} [options] Override http request option.
         * @throws {RequiredError}
         */
        heartbeat(options) {
            const localVarFetchArgs = ApiApiFetchParamCreator(configuration).heartbeat(options);
            return (fetch = defaultFetch, basePath = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    const contentType = response.headers.get('Content-Type');
                    const mimeType = contentType ? contentType.replace(/;.*/, '') : undefined;
                    if (response.status === 200) {
                        if (mimeType === 'application/json') {
                            return response.json();
                        }
                        throw response;
                    }
                    throw response;
                });
            };
        },
        /**
         * @summary List Collections
         * @param {RequestInit} [options] Override http request option.
         * @throws {RequiredError}
         */
        listCollections(options) {
            const localVarFetchArgs = ApiApiFetchParamCreator(configuration).listCollections(options);
            return (fetch = defaultFetch, basePath = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    const contentType = response.headers.get('Content-Type');
                    const mimeType = contentType ? contentType.replace(/;.*/, '') : undefined;
                    if (response.status === 200) {
                        if (mimeType === 'application/json') {
                            return response.json();
                        }
                        throw response;
                    }
                    throw response;
                });
            };
        },
        /**
         * @summary Raw Sql
         * @param {Api.RawSql} request
         * @param {RequestInit} [options] Override http request option.
         * @throws {RequiredError}
         */
        rawSql(request, options) {
            const localVarFetchArgs = ApiApiFetchParamCreator(configuration).rawSql(request, options);
            return (fetch = defaultFetch, basePath = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    const contentType = response.headers.get('Content-Type');
                    const mimeType = contentType ? contentType.replace(/;.*/, '') : undefined;
                    if (response.status === 200) {
                        if (mimeType === 'application/json') {
                            return response.json();
                        }
                        throw response;
                    }
                    if (response.status === 422) {
                        if (mimeType === 'application/json') {
                            throw response;
                        }
                        throw response;
                    }
                    throw response;
                });
            };
        },
        /**
         * @summary Reset
         * @param {RequestInit} [options] Override http request option.
         * @throws {RequiredError}
         */
        reset(options) {
            const localVarFetchArgs = ApiApiFetchParamCreator(configuration).reset(options);
            return (fetch = defaultFetch, basePath = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    const contentType = response.headers.get('Content-Type');
                    const mimeType = contentType ? contentType.replace(/;.*/, '') : undefined;
                    if (response.status === 200) {
                        if (mimeType === 'application/json') {
                            return response.json();
                        }
                        throw response;
                    }
                    throw response;
                });
            };
        },
        /**
         * @summary Root
         * @param {RequestInit} [options] Override http request option.
         * @throws {RequiredError}
         */
        root(options) {
            const localVarFetchArgs = ApiApiFetchParamCreator(configuration).root(options);
            return (fetch = defaultFetch, basePath = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    const contentType = response.headers.get('Content-Type');
                    const mimeType = contentType ? contentType.replace(/;.*/, '') : undefined;
                    if (response.status === 200) {
                        if (mimeType === 'application/json') {
                            return response.json();
                        }
                        throw response;
                    }
                    throw response;
                });
            };
        },
        /**
         * @summary Update
         * @param {string} collectionId
         * @param {Api.UpdateEmbedding} request
         * @param {RequestInit} [options] Override http request option.
         * @throws {RequiredError}
         */
        update(collectionId, request, options) {
            const localVarFetchArgs = ApiApiFetchParamCreator(configuration).update(collectionId, request, options);
            return (fetch = defaultFetch, basePath = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    const contentType = response.headers.get('Content-Type');
                    const mimeType = contentType ? contentType.replace(/;.*/, '') : undefined;
                    if (response.status === 200) {
                        if (mimeType === 'application/json') {
                            return response.json();
                        }
                        throw response;
                    }
                    if (response.status === 422) {
                        if (mimeType === 'application/json') {
                            throw response;
                        }
                        throw response;
                    }
                    throw response;
                });
            };
        },
        /**
         * @summary Update Collection
         * @param {string} collectionId
         * @param {Api.UpdateCollection} request
         * @param {RequestInit} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCollection(collectionId, request, options) {
            const localVarFetchArgs = ApiApiFetchParamCreator(configuration).updateCollection(collectionId, request, options);
            return (fetch = defaultFetch, basePath = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    const contentType = response.headers.get('Content-Type');
                    const mimeType = contentType ? contentType.replace(/;.*/, '') : undefined;
                    if (response.status === 200) {
                        if (mimeType === 'application/json') {
                            return response.json();
                        }
                        throw response;
                    }
                    if (response.status === 422) {
                        if (mimeType === 'application/json') {
                            throw response;
                        }
                        throw response;
                    }
                    throw response;
                });
            };
        },
        /**
         * @summary Upsert
         * @param {string} collectionId
         * @param {Api.AddEmbedding} request
         * @param {RequestInit} [options] Override http request option.
         * @throws {RequiredError}
         */
        upsert(collectionId, request, options) {
            const localVarFetchArgs = ApiApiFetchParamCreator(configuration).upsert(collectionId, request, options);
            return (fetch = defaultFetch, basePath = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    const contentType = response.headers.get('Content-Type');
                    const mimeType = contentType ? contentType.replace(/;.*/, '') : undefined;
                    if (response.status === 200) {
                        if (mimeType === 'application/json') {
                            return response.json();
                        }
                        throw response;
                    }
                    if (response.status === 422) {
                        if (mimeType === 'application/json') {
                            throw response;
                        }
                        throw response;
                    }
                    throw response;
                });
            };
        },
        /**
         * @summary Version
         * @param {RequestInit} [options] Override http request option.
         * @throws {RequiredError}
         */
        version(options) {
            const localVarFetchArgs = ApiApiFetchParamCreator(configuration).version(options);
            return (fetch = defaultFetch, basePath = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    const contentType = response.headers.get('Content-Type');
                    const mimeType = contentType ? contentType.replace(/;.*/, '') : undefined;
                    if (response.status === 200) {
                        if (mimeType === 'application/json') {
                            return response.json();
                        }
                        throw response;
                    }
                    throw response;
                });
            };
        },
    };
};
/**
 * ApiApi - factory interface
 * @export
 */
export const ApiApiFactory = function (configuration, basePath, fetch) {
    return new ApiApi(configuration, basePath, fetch);
};
/**
 * ApiApi - object-oriented interface
 * @export
 * @class ApiApi
 * @extends {BaseAPI}
 */
export class ApiApi extends BaseAPI {
    /**
     * @summary Add
     * @param {string} collectionId
     * @param {Api.AddEmbedding} request
     * @param {RequestInit} [options] Override http request option.
     * @throws {RequiredError}
     */
    add(collectionId, request, options) {
        return ApiApiFp(this.configuration).add(collectionId, request, options)(this.fetch, this.basePath);
    }
    /**
     * @summary Delete
     * @param {string} collectionId
     * @param {Api.DeleteEmbedding} request
     * @param {RequestInit} [options] Override http request option.
     * @throws {RequiredError}
     */
    aDelete(collectionId, request, options) {
        return ApiApiFp(this.configuration).aDelete(collectionId, request, options)(this.fetch, this.basePath);
    }
    /**
     * @summary Get
     * @param {string} collectionId
     * @param {Api.GetEmbedding} request
     * @param {RequestInit} [options] Override http request option.
     * @throws {RequiredError}
     */
    aGet(collectionId, request, options) {
        return ApiApiFp(this.configuration).aGet(collectionId, request, options)(this.fetch, this.basePath);
    }
    /**
     * @summary Count
     * @param {string} collectionId
     * @param {RequestInit} [options] Override http request option.
     * @throws {RequiredError}
     */
    count(collectionId, options) {
        return ApiApiFp(this.configuration).count(collectionId, options)(this.fetch, this.basePath);
    }
    /**
     * @summary Create Collection
     * @param {Api.CreateCollection} request
     * @param {RequestInit} [options] Override http request option.
     * @throws {RequiredError}
     */
    createCollection(request, options) {
        return ApiApiFp(this.configuration).createCollection(request, options)(this.fetch, this.basePath);
    }
    /**
     * @summary Create Index
     * @param {string} collectionName
     * @param {RequestInit} [options] Override http request option.
     * @throws {RequiredError}
     */
    createIndex(collectionName, options) {
        return ApiApiFp(this.configuration).createIndex(collectionName, options)(this.fetch, this.basePath);
    }
    /**
     * @summary Delete Collection
     * @param {string} collectionName
     * @param {RequestInit} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteCollection(collectionName, options) {
        return ApiApiFp(this.configuration).deleteCollection(collectionName, options)(this.fetch, this.basePath);
    }
    /**
     * @summary Get Collection
     * @param {string} collectionName
     * @param {RequestInit} [options] Override http request option.
     * @throws {RequiredError}
     */
    getCollection(collectionName, options) {
        return ApiApiFp(this.configuration).getCollection(collectionName, options)(this.fetch, this.basePath);
    }
    /**
     * @summary Get Nearest Neighbors
     * @param {string} collectionId
     * @param {Api.QueryEmbedding} request
     * @param {RequestInit} [options] Override http request option.
     * @throws {RequiredError}
     */
    getNearestNeighbors(collectionId, request, options) {
        return ApiApiFp(this.configuration).getNearestNeighbors(collectionId, request, options)(this.fetch, this.basePath);
    }
    /**
     * @summary Heartbeat
     * @param {RequestInit} [options] Override http request option.
     * @throws {RequiredError}
     */
    heartbeat(options) {
        return ApiApiFp(this.configuration).heartbeat(options)(this.fetch, this.basePath);
    }
    /**
     * @summary List Collections
     * @param {RequestInit} [options] Override http request option.
     * @throws {RequiredError}
     */
    listCollections(options) {
        return ApiApiFp(this.configuration).listCollections(options)(this.fetch, this.basePath);
    }
    /**
     * @summary Raw Sql
     * @param {Api.RawSql} request
     * @param {RequestInit} [options] Override http request option.
     * @throws {RequiredError}
     */
    rawSql(request, options) {
        return ApiApiFp(this.configuration).rawSql(request, options)(this.fetch, this.basePath);
    }
    /**
     * @summary Reset
     * @param {RequestInit} [options] Override http request option.
     * @throws {RequiredError}
     */
    reset(options) {
        return ApiApiFp(this.configuration).reset(options)(this.fetch, this.basePath);
    }
    /**
     * @summary Root
     * @param {RequestInit} [options] Override http request option.
     * @throws {RequiredError}
     */
    root(options) {
        return ApiApiFp(this.configuration).root(options)(this.fetch, this.basePath);
    }
    /**
     * @summary Update
     * @param {string} collectionId
     * @param {Api.UpdateEmbedding} request
     * @param {RequestInit} [options] Override http request option.
     * @throws {RequiredError}
     */
    update(collectionId, request, options) {
        return ApiApiFp(this.configuration).update(collectionId, request, options)(this.fetch, this.basePath);
    }
    /**
     * @summary Update Collection
     * @param {string} collectionId
     * @param {Api.UpdateCollection} request
     * @param {RequestInit} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateCollection(collectionId, request, options) {
        return ApiApiFp(this.configuration).updateCollection(collectionId, request, options)(this.fetch, this.basePath);
    }
    /**
     * @summary Upsert
     * @param {string} collectionId
     * @param {Api.AddEmbedding} request
     * @param {RequestInit} [options] Override http request option.
     * @throws {RequiredError}
     */
    upsert(collectionId, request, options) {
        return ApiApiFp(this.configuration).upsert(collectionId, request, options)(this.fetch, this.basePath);
    }
    /**
     * @summary Version
     * @param {RequestInit} [options] Override http request option.
     * @throws {RequiredError}
     */
    version(options) {
        return ApiApiFp(this.configuration).version(options)(this.fetch, this.basePath);
    }
}
/**
 * We sometimes represent dates as strings (in models) and as Dates (in parameters) so this
 * function converts them both to a string.
 */
function dateToString(value) {
    if (value instanceof Date) {
        return value.toISOString();
    }
    else if (typeof value === 'string') {
        return value;
    }
    else {
        return undefined;
    }
}
//# sourceMappingURL=api.js.map